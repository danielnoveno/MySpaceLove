<?php


namespace App\Http\Controllers\Api;

use Illuminate\Database\QueryException;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Log;
use App\Http\Controllers\Controller;
use App\Models\DailyMessage;
use App\Models\Space;
use App\Services\DailyMessageGenerator;
use Gemini;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Http;
use Inertia\Inertia;

class DailyMessageApiController extends Controller
{
    private $dailyMessageGenerator;

    public function __construct(DailyMessageGenerator $dailyMessageGenerator)
    {
        $this->dailyMessageGenerator = $dailyMessageGenerator;
    }

    public function index(Request $request, Space $space)
    {
        $this->authorizeSpace($space);

        $search = $request->input('search');
        $date = $request->input('date');

        $query = DailyMessage::where('space_id', $space->id);

        if ($search) {
            $query->where('message', 'like', '%' . $search . '%');
        }

        if ($date) {
            $query->whereDate('date', $date);
        }

        $messages = $query->latest()->get();

        if ($messages->isEmpty() && !$search && !$date) {
            $now = $this->currentDailyMessageNow();
            $autoGenerated = $this->ensureDailyMessageFor($space, $now);

            if ($autoGenerated) {
                $messages = DailyMessage::where('space_id', $space->id)->latest()->get();
            }
        }

        if (request()->has('json')) {
            if ($messages->isNotEmpty()) {
                return response()->json(['message' => $messages->first()]);
            } else {
                return response()->json(['message' => null], 404);
            }
        } else {
            return Inertia::render('DailyMessages/Index', [
                'messages' => $messages,
                'space' => $this->spacePayload($space),
                'filters' => [
                    'search' => $search,
                    'date' => $date,
                ],
            ]);
        }
    }

    public function create(Space $space)
    {
        $this->authorizeSpace($space);

        return Inertia::render('DailyMessages/Create', [
            'space' => $this->spacePayload($space),
        ]);
    }

    public function store(Request $r, Space $space)
    {
        $this->authorizeSpace($space);

        $data = $r->validate([
            'date' => 'required|date',
            'message' => 'required|string',
        ]);

        $dm = DailyMessage::updateOrCreate(
            ['space_id' => $space->id, 'date' => $data['date']],
            ['message' => $data['message'], 'generated_by' => 'manual']
        );

        return redirect(route('daily.index', ['space' => $space->slug]));
    }

    public function regenerate(Space $space)
    {
        $this->authorizeSpace($space);

        $now = $this->currentDailyMessageNow();
        $today = $now->toDateString();

        DailyMessage::where('space_id', $space->id)
            ->where('date', $today)
            ->delete();

        [$fromName, $partnerName] = $this->resolveNamePair($space);
        $text = $this->dailyMessageGenerator->generate(null, null, $fromName, $partnerName);

        if (!$text) {
            return response()->json(['error' => 'Gagal generate pesan AI'], 500);
        }

        $dailyMessage = $this->persistDailyMessage($space, $today, $text, 'ai');

        if (!$dailyMessage) {
            return response()->json(['error' => 'Pesan harian tidak dapat disimpan'], 500);
        }

        return response()->json(['message' => $dailyMessage]);
    }

    public function getTodayMessage(Space $space)
    {
        $this->authorizeSpace($space);

        $now = $this->currentDailyMessageNow();
        $message = $this->ensureDailyMessageFor($space, $now);

        if ($message) {
            return response()->json(['message' => $message]);
        } else {
            return response()->json(['message' => null], 404);
        }
    }

    private function currentDailyMessageNow(): Carbon
    {
        return now($this->dailyMessageTimezone());
    }

    private function dailyMessageTimezone(): string
    {
        $configured = config('love.daily_message.timezone');

        if (is_string($configured) && $configured !== '') {
            return $configured;
        }

        return config('app.timezone', 'UTC');
    }

    private function ensureDailyMessageFor(Space $space, Carbon $now, bool $force = false): ?DailyMessage
    {
        $date = $now->toDateString();

        $existing = DailyMessage::where('space_id', $space->id)
            ->where('date', $date)
            ->first();

        if ($existing) {
            return $existing;
        }

        if (!$this->spaceHasCouple($space)) {
            Log::info('Daily message auto-generation skipped because space has no partner.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        if (!$force && !$this->shouldAutoGenerateMessage($now)) {
            return null;
        }

        [$fromName, $partnerName] = $this->resolveNamePair($space);

        if (!$this->hasUsableNamePair($fromName, $partnerName)) {
            Log::info('Daily message auto-generation skipped because name pair is incomplete.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        $text = $this->dailyMessageGenerator->generate(null, null, $fromName, $partnerName);

        if (!$text) {
            Log::warning('Daily message auto-generation returned empty result.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        return $this->persistDailyMessage($space, $date, $text, 'ai');
    }

    private function persistDailyMessage(
        Space $space,
        string $date,
        string $text,
        string $source
    ): ?DailyMessage {
        try {
            return DailyMessage::firstOrCreate(
                ['space_id' => $space->id, 'date' => $date],
                ['message' => $text, 'generated_by' => $source]
            );
        } catch (QueryException $exception) {
            if ($this->isDuplicateDailyMessage($exception)) {
                return DailyMessage::where('space_id', $space->id)
                    ->where('date', $date)
                    ->first();
            }

            throw $exception;
        }
    }

    private function shouldAutoGenerateMessage(Carbon $now): bool
    {
        [$hour, $minute] = $this->autoGenerateTime();
        $threshold = $now->copy()->setTime($hour, $minute, 0);

        return $now->greaterThanOrEqualTo($threshold);
    }

    private function autoGenerateTime(): array
    {
        $time = (string) config('love.daily_message.auto_generate_time', '05:00');

        if (!preg_match('/^(\d{1,2})(?::(\d{1,2}))?$/', $time, $matches)) {
            return [5, 0];
        }

        $hour = max(0, min(23, (int) $matches[1]));
        $minute = max(0, min(59, isset($matches[2]) ? (int) $matches[2] : 0));

        return [$hour, $minute];
    }

    private function isDuplicateDailyMessage(QueryException $exception): bool
    {
        $sqlState = $exception->errorInfo[0] ?? null;

        if ($sqlState === '23000') {
            return true;
        }

        $message = strtolower($exception->getMessage());

        return str_contains($message, 'duplicate') || str_contains($message, 'unique');
    }

    private function authorizeSpace(Space $space)
    {
        if (!$space->hasMember(Auth::id())) abort(403);
    }

    private function resolveNamePair(Space $space): array
    {
        $space->loadMissing(['userOne', 'userTwo']);

        $currentUser = Auth::user();
        $fromName = $currentUser?->name;
        $partnerName = null;

        if ($currentUser) {
            if ($space->user_one_id === $currentUser->id) {
                $partnerName = optional($space->userTwo)->name;
            } elseif ($space->user_two_id === $currentUser->id) {
                $partnerName = optional($space->userOne)->name;
            }
        }

        if (!$fromName && $space->userOne) {
            $fromName = $space->userOne->name;
        }

        if (!$partnerName) {
            if ($space->userOne && $space->userOne->name !== $fromName) {
                $partnerName = $space->userOne->name;
            } elseif ($space->userTwo && $space->userTwo->name !== $fromName) {
                $partnerName = $space->userTwo->name;
            }
        }

        return [$fromName, $partnerName];
    }

    private function spaceHasCouple(Space $space): bool
    {
        return !empty($space->user_one_id) && !empty($space->user_two_id);
    }

    private function hasUsableNamePair(?string $fromName, ?string $partnerName): bool
    {
        return $this->isFilled($fromName) && $this->isFilled($partnerName);
    }

    private function isFilled(?string $value): bool
    {
        return is_string($value) && trim($value) !== '';
    }

    public function update(Request $request, Space $space, $id)
    {
        $this->authorizeSpace($space);

        $data = $request->validate([
            'date' => 'required|date',
            'message' => 'required|string',
        ]);

        $dailyMessage = DailyMessage::where('space_id', $space->id)->findOrFail($id);

        $dailyMessage->update($data);

        return redirect()->route('daily.index', ['space' => $space->slug])
            ->with('success', 'Daily Message berhasil diperbarui!');
    }

    public function edit(Space $space, $id)
    {
        $this->authorizeSpace($space);

        $dailyMessage = DailyMessage::where('space_id', $space->id)->findOrFail($id);

        return Inertia::render('DailyMessages/Edit', [
            'space' => $this->spacePayload($space),
            'dailyMessage' => $dailyMessage,
        ]);
    }

    private function spacePayload(Space $space): array
    {
        return [
            'id' => $space->id,
            'slug' => $space->slug,
            'title' => $space->title,
        ];
    }
}

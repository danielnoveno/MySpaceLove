<?php


namespace App\Http\Controllers\Api;

use Illuminate\Database\QueryException;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Log;
use App\Http\Controllers\Controller;
use App\Mail\DailyMessageMail;
use App\Models\DailyMessage;
use App\Notifications\DailyMessageSent;
use App\Models\Space;
use App\Models\User;
use App\Services\DailyMessageGenerator;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Mail;
use Inertia\Inertia;
use Throwable;

class DailyMessageApiController extends Controller
{
    private $dailyMessageGenerator;

    public function __construct(DailyMessageGenerator $dailyMessageGenerator)
    {
        $this->dailyMessageGenerator = $dailyMessageGenerator;
    }

    public function index(Request $request, Space $space)
    {
        $this->authorizeSpace($space);

        $search = $request->input('search');
        $date = $request->input('date');

        $query = DailyMessage::where('space_id', $space->id);

        if ($search) {
            $query->where('message', 'like', '%' . $search . '%');
        }

        if ($date) {
            $query->whereDate('date', $date);
        }

        $messages = $query->latest()->get();

        if ($messages->isEmpty() && !$search && !$date) {
            $now = $this->currentDailyMessageNow();
            $autoGenerated = $this->ensureDailyMessageFor($space, $now);

            if ($autoGenerated) {
                $messages = DailyMessage::where('space_id', $space->id)->latest()->get();
            }
        }

        if (request()->has('json')) {
            if ($messages->isNotEmpty()) {
                return response()->json(['message' => $messages->first()]);
            } else {
                return response()->json(['message' => null], 404);
            }
        } else {
            return Inertia::render('DailyMessages/Index', [
                'messages' => $messages,
                'space' => $this->spacePayload($space),
                'filters' => [
                    'search' => $search,
                    'date' => $date,
                ],
            ]);
        }
    }

    public function create(Space $space)
    {
        $this->authorizeSpace($space);

        return Inertia::render('DailyMessages/Create', [
            'space' => $this->spacePayload($space),
        ]);
    }

    public function store(Request $r, Space $space)
    {
        $this->authorizeSpace($space);

        $data = $r->validate([
            'date' => 'required|date',
            'message' => 'required|string',
        ]);

        $dm = DailyMessage::updateOrCreate(
            ['space_id' => $space->id, 'date' => $data['date']],
            ['message' => $data['message'], 'generated_by' => 'manual']
        );

        return redirect(route('daily.index', ['space' => $space->slug]));
    }

    public function sendEmail(Request $request, Space $space, $id)
    {
        $this->authorizeSpace($space);

        $dailyMessage = DailyMessage::where('space_id', $space->id)
            ->where('id', $id)
            ->firstOrFail();

        $partner = $this->resolvePartnerUser($space);

        if (!$partner || !$this->isFilled($partner->email)) {
            return response()->json([
                'error' => trans('app.daily_messages.feedback.email_partner_missing'),
            ], 422);
        }

        /** @var \App\Models\User $sender */
        $sender = Auth::user();

        try {
            Mail::to($partner->email)->send(
                new DailyMessageMail($space, $dailyMessage, $sender, $partner)
            );

            $sender->notify(new DailyMessageSent($dailyMessage, $sender));
        } catch (Throwable $exception) {
            Log::error('Failed to send daily message email.', [
                'space_id' => $space->id,
                'message_id' => $dailyMessage->id,
                'error' => $exception->getMessage(),
            ]);

            return response()->json([
                'error' => trans('app.daily_messages.feedback.email_failed'),
            ], 500);
        }

        return response()->json([
            'message' => trans('app.daily_messages.feedback.email_sent'),
        ]);
    }

    public function getTodayMessage(Space $space)
    {
        $this->authorizeSpace($space);

        $now = $this->currentDailyMessageNow();
        $message = $this->ensureDailyMessageFor($space, $now);

        if ($message) {
            return response()->json(['message' => $message]);
        } else {
            return response()->json(['message' => null], 404);
        }
    }

    public function regenerate(Request $request, Space $space, $id)
    {
        $this->authorizeSpace($space);

        $dailyMessage = DailyMessage::where('space_id', $space->id)
            ->where('id', $id)
            ->firstOrFail();

        // Get names for personalization
        [$fromName, $partnerName] = $this->resolveNamePair($space);

        if (!$this->hasUsableNamePair($fromName, $partnerName)) {
            return response()->json([
                'error' => 'Cannot regenerate message: incomplete name information.',
            ], 422);
        }

        // Get recent messages for context
        $recentMessages = $this->recentMessagesForWeek($space, $dailyMessage->date);
        
        // Generate new message
        $text = $this->dailyMessageGenerator->generate(null, $fromName, $partnerName, $recentMessages);

        if (!$text) {
            return response()->json([
                'error' => 'Failed to generate new message.',
            ], 500);
        }

        // Update the message
        $dailyMessage->update([
            'message' => $text,
            'generated_by' => 'ai',
        ]);

        // Log the regeneration
        Log::info('Daily message regenerated', [
            'space_id' => $space->id,
            'message_id' => $dailyMessage->id,
            'date' => $dailyMessage->date,
            'generator_error' => $this->dailyMessageGenerator->getLastErrorMessage(),
        ]);

        return response()->json([
            'message' => $dailyMessage->fresh(),
            'success' => 'Message regenerated successfully!',
        ]);
    }

    private function currentDailyMessageNow(): Carbon
    {
        return now($this->dailyMessageTimezone());
    }

    private function dailyMessageTimezone(): string
    {
        $configured = config('love.daily_message.timezone');

        if (is_string($configured) && $configured !== '') {
            return $configured;
        }

        return config('app.timezone', 'UTC');
    }

    private function ensureDailyMessageFor(Space $space, Carbon $now, bool $force = false): ?DailyMessage
    {
        $date = $now->toDateString();

        $existing = DailyMessage::where('space_id', $space->id)
            ->where('date', $date)
            ->first();

        if ($existing) {
            return $existing;
        }

        if (!$this->spaceHasCouple($space)) {
            Log::info('Daily message auto-generation skipped because space has no partner.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        if (!$force && !$this->shouldAutoGenerateMessage($now)) {
            return null;
        }

        [$fromName, $partnerName] = $this->resolveNamePair($space);

        if (!$this->hasUsableNamePair($fromName, $partnerName)) {
            Log::info('Daily message auto-generation skipped because name pair is incomplete.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        $recentMessages = $this->recentMessagesForWeek($space, $date);
        $text = $this->dailyMessageGenerator->generate(null, $fromName, $partnerName, $recentMessages);

        if (!$text) {
            Log::warning('Daily message auto-generation returned empty result.', [
                'space_id' => $space->id,
                'date' => $date,
            ]);

            return null;
        }

        return $this->persistDailyMessage($space, $date, $text, 'ai');
    }

    private function persistDailyMessage(
        Space $space,
        string $date,
        string $text,
        string $source
    ): ?DailyMessage {
        try {
            return DailyMessage::firstOrCreate(
                ['space_id' => $space->id, 'date' => $date],
                ['message' => $text, 'generated_by' => $source]
            );
        } catch (QueryException $exception) {
            if ($this->isDuplicateDailyMessage($exception)) {
                return DailyMessage::where('space_id', $space->id)
                    ->where('date', $date)
                    ->first();
            }

            throw $exception;
        }
    }

    private function shouldAutoGenerateMessage(Carbon $now): bool
    {
        [$hour, $minute] = $this->autoGenerateTime();
        $threshold = $now->copy()->setTime($hour, $minute, 0);

        return $now->greaterThanOrEqualTo($threshold);
    }

    private function autoGenerateTime(): array
    {
        $time = (string) config('love.daily_message.auto_generate_time', '05:00');

        if (!preg_match('/^(\d{1,2})(?::(\d{1,2}))?$/', $time, $matches)) {
            return [5, 0];
        }

        $hour = max(0, min(23, (int) $matches[1]));
        $minute = max(0, min(59, isset($matches[2]) ? (int) $matches[2] : 0));

        return [$hour, $minute];
    }

    private function isDuplicateDailyMessage(QueryException $exception): bool
    {
        $sqlState = $exception->errorInfo[0] ?? null;

        if ($sqlState === '23000') {
            return true;
        }

        $message = strtolower($exception->getMessage());

        return str_contains($message, 'duplicate') || str_contains($message, 'unique');
    }

    private function authorizeSpace(Space $space)
    {
        if (!$space->hasMember(Auth::id())) abort(403);
    }

    private function resolveNamePair(Space $space): array
    {
        $space->loadMissing(['userOne', 'userTwo']);

        $currentUser = Auth::user();
        $fromName = $currentUser?->name;
        $partnerName = null;

        if ($currentUser) {
            if ($space->user_one_id === $currentUser->id) {
                $partnerName = optional($space->userTwo)->name;
            } elseif ($space->user_two_id === $currentUser->id) {
                $partnerName = optional($space->userOne)->name;
            }
        }

        if (!$fromName && $space->userOne) {
            $fromName = $space->userOne->name;
        }

        if (!$partnerName) {
            if ($space->userOne && $space->userOne->name !== $fromName) {
                $partnerName = $space->userOne->name;
            } elseif ($space->userTwo && $space->userTwo->name !== $fromName) {
                $partnerName = $space->userTwo->name;
            }
        }

        return [$fromName, $partnerName];
    }

    private function resolvePartnerUser(Space $space): ?User
    {
        $space->loadMissing(['userOne', 'userTwo']);

        $currentUserId = Auth::id();

        if ($currentUserId && $currentUserId === $space->user_one_id) {
            return $space->userTwo;
        }

        if ($currentUserId && $currentUserId === $space->user_two_id) {
            return $space->userOne;
        }

        return null;
    }

    private function spaceHasCouple(Space $space): bool
    {
        return !empty($space->user_one_id) && !empty($space->user_two_id);
    }

    private function hasUsableNamePair(?string $fromName, ?string $partnerName): bool
    {
        return $this->isFilled($fromName) && $this->isFilled($partnerName);
    }

    private function isFilled(?string $value): bool
    {
        return is_string($value) && trim($value) !== '';
    }

    private function spacePayload(Space $space): array
    {
        return [
            'id' => $space->id,
            'slug' => $space->slug,
            'title' => $space->title,
        ];
    }

    private function recentMessagesForWeek(Space $space, string $targetDate): array
    {
        $target = Carbon::parse($targetDate, $this->dailyMessageTimezone());
        $end = $target->copy()->endOfDay();
        $start = $target->copy()->subDays(6)->startOfDay();

        return DailyMessage::where('space_id', $space->id)
            ->whereBetween('date', [$start->toDateString(), $end->toDateString()])
            ->orderByDesc('date')
            ->limit(7)
            ->pluck('message')
            ->toArray();
    }
}
